#!/usr/bin/env bash

set -e

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
PROJECT_DIR="$(cd "$SCRIPT_DIR"; git rev-parse --show-toplevel)"
DEPLOY_BASE_PATH="$PROJECT_DIR/operator/deploy"

function log_err() {
    echo "$@" 1>&2
}

function assert_artifactory_creds() {
    local errors=0
    if [[ -z "${DS_REPO_USER}" ]]; then
        log_err "DS_REPO_USER must be set to a user for datastax-docker.jfrog.io."
        errors=1
    fi

    if [[ -z "{DS_REPO_PASS}" ]]; then
        log_err "DS_REPO_PASS must be set to a password for datastax-docker.jfrog.io."
        errors=1
    fi

    if [[ "$errors" -ne 0 ]]; then
        log_err "Artifactory credentials check failed. Exiting."
        exit "$errors"
    fi
}

function assert_deps() {
    for cmd in jq ctool kubectl curl; do
        if ! command -v "$cmd" 1> /dev/null; then
            log_err "Command '$cmd' not found!"
            errors=1
        fi
    done

    if [[ "$errors" -ne 0 ]]; then
        log_err "Dependency check(s) failed. Exiting."
        exit "$errors"
    fi
}

function ctool_cluster_exists() {
    local name="$1"
    ctool list \
        | grep --only-matching --extended-regexp '^[^,]+' \
        | grep --extended-regexp "^${name}\$"
}

function create_kubespray_cluster() {
    local kubespray_cluster_name="$1"
    if ! ctool_cluster_exists "$kubespray_cluster_name"; then
        # Use Xenial for the platform so that we don't have to figure
        # out how to install kubespray on other platforms.
        ctool create --platform=xenial "$kubespray_cluster_name" 1
    fi
}

function get_k8s_ips() {
    local k8s_cluster_name="$1"
    ctool info "$k8s_cluster_name" --public-ips --separator ' '
}

function create_k8s_cluster() {
    local k8s_cluster_name="$1"

    if ! ctool_cluster_exists "$k8s_cluster_name"; then
        ctool create $@
    fi
}

function get_inventory_dir() {
    local k8s_cluster_name="$1"
    echo -n "inventory/kctool_$k8s_cluster_name"
}

function provision_kubespray() {
    local kubespray_cluster_name="$1"
    local k8s_cluster_name="$2"

    local inventory_dir="$(get_inventory_dir "$k8s_cluster_name")"
    local private_key_path="\$PWD/.ssh/kctool_${k8s_cluster_name}_private_key"
    local ssh_entry_start_string="# Generated by kctool: START $k8s_cluster_name \$ip"
    local ssh_entry_end_string="# Generated by kctool: END $k8s_cluster_name \$ip"
    local ips
    local ssh_key
    local ssh_user

    ips="$(get_k8s_ips "$k8s_cluster_name")" || return $?
    ssh_key="$(ctool dump_key "$k8s_cluster_name")" || return $?
    ssh_user="$(\
        ctool run --machine-readable "$k8s_cluster_name" 0 whoami \
        | jq --raw-output '.[0].out')" \
        || return $?

    ctool ssh "$kubespray_cluster_name" <<EOF
        set -e

        # Install base packages
        sudo apt-get -y update
        sudo apt-get -y install python3 python3-pip python-dev python3-dev \
            python3-setuptools build-essential libssl-dev libffi-dev \
            libxml2-dev libxslt1-dev zlib1g-dev

        # Add private key for cluster
        rm --force "$private_key_path"
        echo "$ssh_key" > "$private_key_path"
        chmod 400 "$private_key_path"

        # Add ssh connection information for each k8s node
        for ip in $ips; do
            # Only add an entry if we don't already have one
            if ! grep "$ssh_entry_start_string" ~/.ssh/config > /dev/null; then
                echo "$ssh_entry_start_string" >> ~/.ssh/config
                echo "Host \$ip" >> ~/.ssh/config
                echo "  Hostname \$ip" >> ~/.ssh/config
                echo "  User $ssh_user" >> ~/.ssh/config
                echo "  IdentityFile $private_key_path" >> ~/.ssh/config
                echo "$ssh_entry_end_string" >> ~/.ssh/config
            fi
        done

        # Clone the repo if necessary
        if [[ ! -e kubespray ]]; then
            git clone --branch=v2.11.0 https://github.com/kubernetes-sigs/kubespray.git
        fi

        cd kubespray

        # Install dependencies
        sudo pip3 install --requirement requirements.txt
        # for some reason after installing the dependencies, we get a version of
        # cryptography that is too old, so we fix that
        sudo pip3 install --upgrade cryptography

        # Setup the cluster config
        if [[ ! -e "$inventory_dir" ]]; then
            cp --recursive --force --preserve inventory/sample "$inventory_dir"
        fi

        declare -a IPS=($ips)
        CONFIG_FILE="$inventory_dir/hosts.yml" python3 contrib/inventory_builder/inventory.py \${IPS[@]}

        # Run the playbook
        ansible-playbook \
            --inventory="$inventory_dir/hosts.yml" \
            --become \
            --verbose \
            cluster.yml
EOF
}

function retrieve_kubectl_config() {
    local kubespray_cluster_name="$1"
    local k8s_cluster_name="$2"

    local inventory_dir
    inventory_dir="$(get_inventory_dir "$k8s_cluster_name")" || return $?

    local cmd_get_master="\
        cd kubespray && \
        ansible \
          --inventory "$inventory_dir/hosts.yml" \
          --list-hosts kube-master"
    local host
    host=$(set -e -o pipefail; \
        ctool run --machine-readable "$kubespray_cluster_name" "$cmd_get_master" \
        | jq --raw-output '.[0].out' \
        | tail -n -1) || return $?

    local cmd_get_kubeconf="\
        cd kubespray && \
        ansible \
            --inventory "$inventory_dir/hosts.yml" \
            --become \
            --module-name command \
            --args 'cat /etc/kubernetes/admin.conf' $host \
            | tail -n +2"
    (set -e -o pipefail; \
        ctool run --machine-readable "$kubespray_cluster_name" "$cmd_get_kubeconf" \
        | jq --raw-output '.[0].out') || return $?
}

function kubectl() {
    if [[ -z "$KUBECONFIG_CONTENT" ]]; then
        echo "KUBECONFIG_CONTENT is not defined" 1>&2
        return 1
    fi
    local status
    set +e
    KUBECONFIG=<(echo "$KUBECONFIG_CONTENT") command kubectl $@
    status=$?
    set -e
    return "$status"
}

function create_secret() {
    local namespace="$1"
    local user="$2"
    local pass="$3"
    kubectl create secret docker-registry dse-operator-artifactory-secret \
        --namespace="$namespace" \
        --docker-server="datastax-docker.jfrog.io" \
        --docker-username="$user" \
        --docker-password="$pass" \
        || echo "Skipping secret"
}

function deploy_operator() {
    local namespace="$1"
    local operator_image="$2"

    create_secret "$namespace" "$DS_REPO_USER" "$DS_REPO_PASS"

    kubectl apply \
        --wait \
        --filename "$DEPLOY_BASE_PATH/kind/rancher-local-path-storage.yaml"

    kubectl apply \
        --wait \
        --namespace "$namespace" \
        --filename "$DEPLOY_BASE_PATH/role.yaml"

    kubectl apply \
        --wait \
        --namespace "$namespace" \
        --filename "$DEPLOY_BASE_PATH/role_binding.yaml"

    kubectl apply \
        --wait \
        --namespace "$namespace" \
        --filename "$DEPLOY_BASE_PATH/service_account.yaml"

    kubectl apply \
        --wait \
        --namespace "$namespace" \
        --filename "$DEPLOY_BASE_PATH/crds/datastax_v1alpha1_dsedatacenter_crd.yaml"

    kubectl apply \
        --wait \
        --namespace "$namespace" \
        --filename <(sed -E "s#datastax/dse-operator[^\"]*#$operator_image#" "$DEPLOY_BASE_PATH/operator.yaml")
}

function do_usage() {
    local text="\
usage: kctool [options] <command>

optional aguments:
-s, --kubespray-cluster   Name of ctool cluster for kubespray
-h, --help                Displays this usage information

commands:
create <cluster_name> <size>  [-- ctool_args...]
                  Creates and provisions a Kubernetes cluster of the specified
                  size
destroy <cluster_name>
                  Deletes the Kubernetes cluster
kubeconfig <cluster_name>
                  Prints a suitable kubeconfig for use with kubectl
deploy <cluster_name> [--image <image>] [--namespace <namespace>]
                  Deploys the operator. By default, uses image for the current
                  HEAD but may specify an image to use (e.g.
                  datastaxlabs/dse-k8s-operator:0.3.0-20190822). By default,
                  uses the default namespaces but may specify a different one."
    echo "$text"
    return 0
}

function log_arg_err() {
    local message="$1"
    log_err "$message"
    do_usage 1>&2
    return 1
}

function required_value() {
    local value="$1"
    local message="$2"

    if [[ -z "$value" ]]; then
        log_arg_err "$message"
        return $?
    fi

    return 0
}

function get_kubespray_cluster_name() {
    local given_kubespray_cluster_name="$1"
    local k8s_cluster_name="$2"

    if [[ -z "$given_kubespray_cluster_name" ]]; then
        given_kubespray_cluster_name="${k8s_cluster_name}_kubespray"
    fi
    echo "$given_kubespray_cluster_name"
}

function do_create() {
    local kubespray_cluster_name="$1"
    shift
    local k8s_cluster_name
    local k8s_cluster_size
    local create_k8s_args=()
    local current_positional_arg=0

    while [[ ! -z "$1" ]]; do
        case "$1" in
            --)
                shift
                create_k8s_args=( "${create_k8s_args[@]}" "$@" )
                break
                ;;
            -*|--*)
                log_arg_err "Unexpected argument: $1"
                return $?
                ;;
            *)
                if [[ "$current_positional_arg" -eq 0 ]]; then
                    k8s_cluster_name="$1"
                elif [[ "$current_positional_arg" -eq 1 ]]; then
                    k8s_cluster_size="$1"
                else
                    log_arg_err "Unexpected argument: $1"
                    return $?
                fi
                current_positional_arg=$(expr 1 + $current_positional_arg)
                shift
                ;;
        esac
    done

    required_value "$k8s_cluster_name" "Must specify kubernetes cluster name" || return $?
    required_value "$k8s_cluster_size" "Must specify cluster size" || return $?

    kubespray_cluster_name="$(get_kubespray_cluster_name "$kubespray_cluster_name" "$k8s_cluster_name")"

    create_k8s_cluster "$k8s_cluster_name" "$k8s_cluster_size" "${create_k8s_args[@]}"
    create_kubespray_cluster "$kubespray_cluster_name"
    provision_kubespray "$kubespray_cluster_name" "$k8s_cluster_name"
}

function do_delete() {
    local kubespray_cluster_name="$1"
    local k8s_cluster_name="$2"
    kubespray_cluster_name="$(get_kubespray_cluster_name "$kubespray_cluster_name" "$k8s_cluster_name")"
    ctool destroy --skip-print "$kubespray_cluster_name"
    ctool destroy --skip-print "$k8s_cluster_name"
}

function do_kubeconfig() {
    local kubespray_cluster_name="$1"
    local k8s_cluster_name="$2"
    kubespray_cluster_name="$(get_kubespray_cluster_name "$kubespray_cluster_name" "$k8s_cluster_name")"
    retrieve_kubectl_config "$kubespray_cluster_name" "$k8s_cluster_name"
}

function load_artifactory_creds() {
    if [[ -z "$DS_REPO_PASS" ]] || [[ -z "$DS_REPO_USER" ]]; then
        # credentials not specified, lets attempt to use QA credentials
        echo "Artifactory credentials not specified. Attempting to use QA credentials."
        local qacreds
        if qacreds="$(curl http://repomirror.datastax.lan/ctool/creds.txt)"; then
            DS_REPO_USER=$(echo "$qacreds" \
                | grep 'artifactory_user' \
                | grep --only-matching --extended-regexp  '=\s*[^\s]+' \
                | grep --only-matching --extended-regexp '[^\s=]+' \
                | tr -d '[:space:]')
            DS_REPO_PASS=$(echo "$qacreds" \
                | grep 'artifactory_pass' \
                | grep --only-matching --extended-regexp  '=\s*[^\s]+' \
                | grep --only-matching --extended-regexp '[^\s=]+' \
                | tr -d '[:space:]')
        else
            log_err "Could not load QA credentials. Are you not on the VPN?"
        fi
    fi
}

function do_deploy() {
    local kubespray_cluster_name="$1"
    shift
    local namespace="default"
    local current_positional_arg=0

    while [[ ! -z "$1" ]]; do
        case "$1" in
            -i|--image)
                shift
                image="$1"
                shift
                ;;
            -n|--namespace)
                shift
                namespace="$1"
                shift
                ;;
            -p|--artifactory-token)
                shift
                DS_REPO_PASS="$1"
                shift
                ;;
            -u|--artifactory-user)
                shift
                DS_REPO_USER="$1"
                shift
                ;;
            -*|--*)
                log_arg_err "Unexpected argument: $1"
                return $?
                ;;
            *)
                if [[ "$current_positional_arg" -eq 0 ]]; then
                    k8s_cluster_name="$1"
                else
                    log_arg_err "Unexpected argument: $1"
                    return $?
                fi
                current_positional_arg=$(expr 1 + $current_positional_arg)
                shift
                ;;
        esac
    done

    required_value "$k8s_cluster_name" "Must specify kubernetes cluster name" || return $?
    kubespray_cluster_name="$(get_kubespray_cluster_name "$kubespray_cluster_name" "$k8s_cluster_name")"

    load_artifactory_creds
    assert_artifactory_creds

    local branch_name=

    if [[ -z "$image" ]]; then
        if ! branch_name=$(git symbolic-ref --short HEAD); then
            branch_name="master"
        fi
        local revision="$(git rev-parse HEAD)"
        image="$(echo "datastax-docker.jfrog.io/dse-operator/operator:${branch_name}.${revision}")"
    fi

    KUBECONFIG_CONTENT="$(retrieve_kubectl_config "$kubespray_cluster_name" "$k8s_cluster_name")"
    deploy_operator "$namespace" "$image"
}

function main() {
    local kubespray_cluster_name=""
    # local k8s_cluster_name="k8s"

    assert_deps

    while [[ ! -z "$1" ]]; do
        case "$1" in
            -s|--kubespray-cluster)
                shift
                kubespray_cluster_name="$1"
                shift
                ;;
            -h|--help)
                shift
                do_usage
                return
                ;;
            create)
                shift
                do_create "$kubespray_cluster_name" $@
                return $?
                ;;
            destroy)
                shift
                do_delete "$kubespray_cluster_name" $@
                return $?
                ;;
            kubeconfig)
                shift
                do_kubeconfig "$kubespray_cluster_name" $@
                return $?
                ;;
            deploy)
                shift
                do_deploy "$kubespray_cluster_name" $@
                return $?
                ;;
            *)
                log_arg_err "Unexpected argument: $1"
                return $?
                ;;
        esac
    done

    log_arg_err "No command specified."
    return $?
}

main $@
